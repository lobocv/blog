<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Lobocv Blog</title><link>http://blog.lobocv.com/</link><description>Recent content on Lobocv Blog</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sat, 01 Oct 2022 00:00:00 +0000</lastBuildDate><atom:link href="http://blog.lobocv.com/index.xml" rel="self" type="application/rss+xml"/><item><title>Unit testing complex workflows in Go</title><link>http://blog.lobocv.com/posts/golang_testing/</link><pubDate>Sat, 01 Oct 2022 00:00:00 +0000</pubDate><guid>http://blog.lobocv.com/posts/golang_testing/</guid><description>The standard library testing package in Go does many things well. It is simple to use and executes fast and efficiently, even running tests in parallel and the caching results. However, many including myself, have turned to supplemental packages to address some blind spots when writing tests:
Test setup, teardown and grouping Assertions and output validation Mocking I have found that these blind spots become particularly cumbersome when you have workflows that involve sophisticated fixture setup, multiple edge cases, error handling, mocks, and complex outputs.</description></item><item><title>Advanced Go Error Handling Made Simple</title><link>http://blog.lobocv.com/posts/richer_golang_errors/</link><pubDate>Tue, 22 Mar 2022 00:00:00 +0000</pubDate><guid>http://blog.lobocv.com/posts/richer_golang_errors/</guid><description>One of the most notorious design decisions of Go is how it approaches error handling. Go handles errors explicitly by returning them as values from any function that can possibly raise an error. To many, this way of error handling is uncomfortable at first. The tediousness of having every function not only return an optional error but also check the returned error from every function seemed to be too tedious.</description></item><item><title>Defusing an ElasticSearch Mapping Explosion with Slots</title><link>http://blog.lobocv.com/posts/elasticsearch_slots/</link><pubDate>Sun, 12 Dec 2021 00:00:00 +0000</pubDate><guid>http://blog.lobocv.com/posts/elasticsearch_slots/</guid><description>ElasticSearch (and similarly OpenSearch[1]) is a popular OLAP database that allows you to quickly search and aggregate your data in a rich and powerful way. It is a mature storage technology build on top of Apache Lucene that has been used to back many online storefronts and analytical processing products around the world. Under the hood, ElasticSearch uses Lucene to index each field in the document so that queries can be executed efficiently.</description></item><item><title>Reducing System Load With Event Folding</title><link>http://blog.lobocv.com/posts/event_folding/</link><pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate><guid>http://blog.lobocv.com/posts/event_folding/</guid><description>One of the prevailing forms of communication in modern microservice architectures is asynchronous messaging. This is the backbone of the event-driven architecture model. In this model, services send messages to a message broker, which then distributes (publishes) the messages to interested (subscribed) clients. A message can be used to describe an event in the system, such as the creation or update of an entity. This allows you to loosely couple different components of your system by having them publish or subscribe to events that they care about.</description></item><item><title>Building a Comfortable Dev Environment</title><link>http://blog.lobocv.com/posts/dev_environment/</link><pubDate>Tue, 06 Jul 2021 00:00:00 +0000</pubDate><guid>http://blog.lobocv.com/posts/dev_environment/</guid><description>Being a software developer can be overwhelming at times. There are an endlessly diverse set of tools, technologies, languages and frameworks to choose from. To make it worse, that list grows larger and larger each day. Tools like git, docker, docker-compose, kubernetes, ssh, curl, sed, awk, grep, jq etc. are all tools we use multiple times a day.
Most of these tools have a small subset of commands / flags or use-cases that we use most often.</description></item><item><title>Recursively Merging JSONB in PostgreSQL</title><link>http://blog.lobocv.com/posts/recursive_jsonb_merge/</link><pubDate>Sat, 01 May 2021 00:00:00 +0000</pubDate><guid>http://blog.lobocv.com/posts/recursive_jsonb_merge/</guid><description>In addition to storing primitive data types such as INT, FLOAT and VARCHAR, PostgreSQL supports storing JSON and binary JSON (JSONB). These JSON types have a wide variety of functions and operators[1]. One of the more common and useful operators is the concatenation operator, ||, which concatenates two jsonb values into a new JSONB value.
Example:
postgres=&amp;gt; SELECT &amp;#39;{&amp;#34;a&amp;#34;: 1, &amp;#34;b&amp;#34;: 2}&amp;#39;::jsonb || &amp;#39;{&amp;#34;b&amp;#34;: 5, &amp;#34;c&amp;#34;: 6}&amp;#39;::jsonb as result; result -------------------------- {&amp;#34;a&amp;#34;: 1, &amp;#34;b&amp;#34;: 5, &amp;#34;c&amp;#34;: 6} However, this concatenation is limiting.</description></item><item><title>About</title><link>http://blog.lobocv.com/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://blog.lobocv.com/about/</guid><description>I am a backend software developer that has a passion for software architecture, scalability, development efficiency and clean code. I love learning and sharing what I have learned with others.
Aside from work, I love to play electric guitar, renovate my home and be out in nature.</description></item></channel></rss>