[{"title":"Recursively Merging JSONB in PostgreSQL","date":"","description":"","body":"In addition to storing primitive data types such as INT, FLOAT and VARCHAR, PostgreSQL supports storing JSON and binary JSON (JSONB). These JSON types have a wide variety of functions and operators[1]. One of the more common and useful operators is the concatenation operator, ||, which concatenates two jsonb values into a new JSONB value.\nExample:\npostgres=\u0026gt; SELECT \u0026#39;{\u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2}\u0026#39;::jsonb || \u0026#39;{\u0026#34;b\u0026#34;: 5, \u0026#34;c\u0026#34;: 6}\u0026#39;::jsonb as result; result -------------------------- {\u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 5, \u0026#34;c\u0026#34;: 6} However, this concatenation is limiting. For one, if a key is present in both arguments, the second value will completely overwrite the first. This is a problem for nested objects. The following example attempts to update the \u0026quot;author.age\u0026quot; value from 30 to 31, but also ends up removing the author.name field.\nSELECT \u0026#39;{\u0026#34;author\u0026#34;: {\u0026#34;age\u0026#34;: 30, \u0026#34;name\u0026#34;: \u0026#34;Calvin\u0026#34;}}\u0026#39;::jsonb || \u0026#39;{\u0026#34;author\u0026#34;: {\u0026#34;age\u0026#34;: 31}}\u0026#39;::jsonb as result; result -------------------- {\u0026#34;author\u0026#34;: {\u0026#34;age\u0026#34;: 31}} In order to preserve objects and have their fields merged instead of overwritten, we need to write a custom function.\nHere is the full function which recursively merges two JSON objects A  and B:\nCREATE OR REPLACE FUNCTION jsonb_recursive_merge(A jsonb, B jsonb) RETURNS jsonb LANGUAGE SQL AS $$ SELECT jsonb_object_agg( coalesce(ka, kb), CASE WHEN va isnull THEN vb WHEN vb isnull THEN va WHEN jsonb_typeof(va) \u0026lt;\u0026gt; \u0026#39;object\u0026#39; OR jsonb_typeof(vb) \u0026lt;\u0026gt; \u0026#39;object\u0026#39; THEN vb ELSE jsonb_recursive_merge(va, vb) END ) FROM jsonb_each(A) temptable1(ka, va) FULL JOIN jsonb_each(B) temptable2(kb, vb) ON ka = kb $$; This function may be a bit hard to digest, so let\u0026rsquo;s break it down:\nSELECT jsonb_object_agg( ... ) FROM jsonb_each(A) temptableA(ka, va) FULL JOIN jsonb_each(B) temptableB(kb, vb) ON ka = kb jsonb_object_agg is a built-in postgresql function which aggregates a list of (key, value) pairs into a JSON object. This is what creates the final merged JSON result. Here we are applying jsonb_object_agg on the results of an in-memory temporary table that we are creating on the fly.\nTemporary tables jsonb_each() is a built-in postgresql function that iterates a JSON object returning (key, value) pairs. We call this function on both input JSON object A and B and then store the results in temporary tables temptableA and temptableB respectively.\ntemptableA(ka, va) is the definition of a temporary table with columns ka and va for the key and value results of jsonb_each(). This is where ka and va are first introduced. We do the exact same thing for JSON object B to get kb and vb.\nNext we do a FULL JOIN with the two temporary tables on the key column. This gives us one table that has all the (key, value) pairs from both JSON objects A and B. Below is an example of what the results of that table may look like:\n   ka va kb vb     likes 5 likes 10     comments 3   shares 1     impressions 65 impressions 130    Table 1: An example of a FULL JOIN with two temporary tables produced by jsonb_each()\nIt is this table from which we select the input to jsonb_object_agg(). As we iterate through the rows of this joined temporary table, we need to determine which key (ka or kb) and value (va or vb) we want to place in the resultant JSON object.\nSelecting the Key coalesce(ka, kb) coalesce is a built in postgresql function that returns the first non null value it is given. In this case it will choose ka if kb is null or kb if ka is null. Since we performed our FULL JOIN on columns ka = kb, we are guaranteed to have a non-null value for either ka or kb. When both ka and kb are non-null, they will be the same value.\nSelecting the Value CASE WHEN va isnull THEN vb WHEN vb isnull THEN va WHEN jsonb_typeof(va) \u0026lt;\u0026gt; \u0026#39;object\u0026#39; OR jsonb_typeof(vb) \u0026lt;\u0026gt; \u0026#39;object\u0026#39; THEN vb ELSE jsonb_recursive_merge(va, vb) END To select the value, we have a switch statement. The first two cases chooses the non-null value when one of the values is null. The third case is when both va and vb are defined and not both JSON objects themselves. In this case we choose vb over va (remember we are merging B into A). The final case (else) handles the situation where va and vb are both JSON objects. In that situation we recursively call the jsonb_recursive_merge on va and vb.\nAnd there you have it, a custom PostgreSQL function that merges two JSON objects, preserving and merging any nested objects. I\u0026rsquo;d like to thank and give credit to klin and his very helpful StackOverflow answer which brought me to a solution to this problem.\nUsing the function One common use for this function is to upsert a row. In an upsert, when the row exists, you want to update it and when it doesn\u0026rsquo;t a new row is inserted. To do this, you would use an INSERT statement with the ON CONFLICT (col1,..., colN) DO UPDATE SET clause. The columns in the clause specify the columns of a unique index. Following the clause is a list of column_name = \u0026lt;expression\u0026gt; statements that decide just how each column is to be updated.\nBelow is an example of updating a table of tweet metrics:\nINSERT INTO tweets (id, metrics) VALUES (1, 0) ON CONFLICT (id) DO UPDATE SET metrics = jsonb_recursive_merge(tweets.metrics, excluded.metrics); In the statement above, if a row with the same ID exists, it will call the jsonb_recursive_merge function on the current value, tweets.metrics, and the inserted value, excluded.metrics (the excluded table is the name of the special table representing rows proposed for insertion[2]).\nLimitations When we designed our jsonb_recursive_merge function we had to decide what \u0026ldquo;merge\u0026rdquo; meant to us. We decided that an overwrite of a value constitutes a \u0026ldquo;merge\u0026rdquo;. But what about values that are arrays? One could argue that merging two arrays [1, 2, 3] and [4, 5, 6] should result in [1,2,3,4,5,6]. It really all depends on the context of what you are trying to do.\nIf you want to also merge the values of arrays you can add an extra case statement that appends the values when both va and vb are arrays:\nWHEN jsonb_typeof(va) = \u0026#39;array\u0026#39; AND jsonb_typeof(vb) = \u0026#39;array\u0026#39; THEN va || vb However, be aware that this will apply to all arrays encountered in the JSON objects.\nFurther Reading [1] JSON Functions and Operators\n[2] PostgresSQL Insert Documentation\n","ref":"/posts/recursive_jsonb_merge/"},{"title":"About","date":"","description":"","body":"I am a backend software developer that has a passion for software architecture, scalability, development efficiency and clean code. I love learning and sharing what I have learned with others.\nAside from work, I love to play electric guitar, renovate my home and be out in nature.\n","ref":"/about/"}]