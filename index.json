[{"title":"Recursively Merging JSONB in PostgreSQL","date":"","description":"","body":"In addition to storing primitive data types such as INT, FLOAT and VARCHAR, PostgreSQL supports storing JSON and binary JSON (JSONB). These JSON types have a wide variety of functions and operators. One of the more common and useful operators is the concatenation operator, ||, which concatenates two jsonb values into a new JSONB value.\nExample:\npostgres=\u0026gt; SELECT \u0026#39;{\u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2}\u0026#39;::jsonb || \u0026#39;{\u0026#34;b\u0026#34;: 5, \u0026#34;c\u0026#34;: 6}\u0026#39;::jsonb as result; result -------------------------- {\u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 5, \u0026#34;c\u0026#34;: 6} However, this concatenation is limiting. For one, if a key is present in both arguments, the second value will completely overwrite the first. This is a problem for nested objects. The following example attempts to update the \u0026quot;author.age\u0026quot; value from 30 to 31, but also ends up removing the author.name field.\nSELECT \u0026#39;{\u0026#34;author\u0026#34;: {\u0026#34;age\u0026#34;: 30, \u0026#34;name\u0026#34;: \u0026#34;Calvin\u0026#34;}}\u0026#39;::jsonb || \u0026#39;{\u0026#34;author\u0026#34;: {\u0026#34;age\u0026#34;: 31}}\u0026#39;::jsonb as result; result -------------------- {\u0026#34;author\u0026#34;: {\u0026#34;age\u0026#34;: 31}} In order to preserve objects and have their fields merged instead of overwritten, we need to write a custom function.\nHere is the full function which recursively merges two JSON objects A  and B:\nCREATE OR REPLACE FUNCTION jsonb_recursive_merge(A jsonb, B jsonb) RETURNS jsonb LANGUAGE SQL AS $$ SELECT jsonb_object_agg( coalesce(ka, kb), CASE WHEN va isnull THEN vb WHEN vb isnull THEN va WHEN jsonb_typeof(va) \u0026lt;\u0026gt; \u0026#39;object\u0026#39; OR jsonb_typeof(vb) \u0026lt;\u0026gt; \u0026#39;object\u0026#39; THEN vb ELSE jsonb_recursive_merge(va, vb) END ) FROM jsonb_each(A) temptable1(ka, va) FULL JOIN jsonb_each(B) temptable2(kb, vb) ON ka = kb $$; This function may be a bit hard to digest, so let\u0026rsquo;s break it down:\nSELECT jsonb_object_agg( ... ) FROM jsonb_each(A) temptableA(ka, va) FULL JOIN jsonb_each(B) temptableB(kb, vb) ON ka = kb jsonb_object_agg is a built-in postgresql function which aggregates a list of (key, value) pairs into a JSON object. This is what creates the final merged JSON result. Here we are applying jsonb_object_agg on the results of an in-memory temporary table that we are creating on the fly.\nTemporary tables jsonb_each() is a built-in postgresql function that iterates a JSON object returning (key, value) pairs. We call this function on both input JSON object A and B and then store the results in temporary tables temptableA and temptableB respectively.\ntemptableA(ka, va) is the definition of a temporary table with columns ka and va for the key and value results of jsonb_each(). This is where ka and va are first introduced. We do the exact same thing for JSON object B to get kb and vb.\nNext we do a FULL JOIN with the two temporary tables on the key column. This gives us one table that has all the (key, value) pairs from both JSON objects A and B. Below is an example of what the results of that table may look like:\n   ka va kb vb     likes 5 likes 10     comments 3   shares 1     impressions 65 impressions 130    Table 1: An example of a FULL JOIN with two temporary tables produced by jsonb_each()\nIt is this table from which we select the input to jsonb_object_agg(). As we iterate through the rows of this joined temporary table, we need to determine which key (ka or kb) and value (va or vb) we want to place in the resultant JSON object.\nSelecting the Key coalesce(ka, kb) coalesce is a built in postgresql function that returns the first non null value it is given. In this case it will choose ka if kb is null or kb if ka is null. Since we performed our FULL JOIN on columns ka = kb, we are guaranteed to have a non-null value for either ka or kb. When both ka and kb are non-null, they will be the same value.\nSelecting the Value CASE WHEN va isnull THEN vb WHEN vb isnull THEN va WHEN jsonb_typeof(va) \u0026lt;\u0026gt; \u0026#39;object\u0026#39; OR jsonb_typeof(vb) \u0026lt;\u0026gt; \u0026#39;object\u0026#39; THEN vb ELSE jsonb_recursive_merge(va, vb) END To select the value, we have a switch statement. The first two cases chooses the non-null value when one of the values is null. The third case is when both va and vb are defined and not both JSON objects themselves. In this case we choose vb over va (remember we are merging B into A). The final case (else) handles the situation where va and vb are both JSON objects. In that situation we recursively call the jsonb_recursive_merge on va and vb.\nAnd there you have it, a custom PostgreSQL function that merges two JSON objects, preserving and merging any nested objects. I\u0026rsquo;d like to thank and give credit to klin and his very helpful StackOverflow answer which brought me to a solution to this problem.\nFurther Reading JSON Functions and Operators\n","ref":"/posts/recursive_jsonb_merge/"},{"title":"About","date":"","description":"","body":"About me!\n","ref":"/about/"}]